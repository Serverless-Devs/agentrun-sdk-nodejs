/**
 * This file is auto generated by the code generation script.
 * Do not modify this file manually.
 * Use the `bun run codegen` command to regenerate.
 *
 * 当前文件为自动生成的控制 API 客户端代码。请勿手动修改此文件。
 * 使用 `bun run codegen` 命令重新生成。
 */

// Source: sandbox_control_api.yaml

import * as $AgentRun from '@alicloud/agentrun20250910';
import * as $Util from '@alicloud/tea-util';

import { Config } from '../../utils/config';
import { ControlAPI } from '../../utils/control-api';
import { ClientError, ServerError } from '../../utils/exception';
import { logger } from '../../utils/log';

/**
 * Sandbox Control API
 */
export class SandboxControlAPI extends ControlAPI {
  constructor(config?: Config) {
    super(config);
  }

  /**
   * Create Sandbox Template
   *
   * @param params - Method parameters
   * @param params.input - Template configuration
   * @param params.headers - Custom request headers
   * @param params.config - Optional config override
   * @returns Created Template object
   */
  createTemplate = async (params: {
    input: $AgentRun.CreateTemplateInput;
    headers?: Record<string, string>;
    config?: Config;
  }): Promise<$AgentRun.Template> => {
    const { input, headers, config } = params;

    try {
      const client = this.getClient(config);
      const runtime = new $Util.RuntimeOptions({});

      const response = await client.createTemplateWithOptions(
        new $AgentRun.CreateTemplateRequest({ body: input }),
        headers ?? {},
        runtime
      );

      logger.debug(
        `request api createTemplate, request Request ID: ${response.body?.requestId}\n  request: ${JSON.stringify([input])}\n  response: ${JSON.stringify(response.body?.data)}`
      );

      return response.body?.data as $AgentRun.Template;
    } catch (error: unknown) {
      if (error && typeof error === 'object' && 'statusCode' in error) {
        const e = error as { statusCode: number; message: string; data?: { requestId?: string } };
        const statusCode = e.statusCode;
        const message = e.message || 'Unknown error';
        const requestId = e.data?.requestId;

        if (statusCode >= 400 && statusCode < 500) {
          throw new ClientError(statusCode, message, { requestId });
        } else if (statusCode >= 500) {
          throw new ServerError(statusCode, message, { requestId });
        }
      }
      throw error;
    }
  };

  /**
   * Delete Sandbox Template
   *
   * @param params - Method parameters
   * @param params.templateName - Template name
   * @param params.headers - Custom request headers
   * @param params.config - Optional config override
   * @returns Deleted Template object
   */
  deleteTemplate = async (params: {
    templateName: string;
    headers?: Record<string, string>;
    config?: Config;
  }): Promise<$AgentRun.Template> => {
    const { templateName, headers, config } = params;

    try {
      const client = this.getClient(config);
      const runtime = new $Util.RuntimeOptions({});

      const response = await client.deleteTemplateWithOptions(templateName, headers ?? {}, runtime);

      logger.debug(
        `request api deleteTemplate, request Request ID: ${response.body?.requestId}\n  request: ${JSON.stringify([templateName])}\n  response: ${JSON.stringify(response.body?.data)}`
      );

      return response.body?.data as $AgentRun.Template;
    } catch (error: unknown) {
      if (error && typeof error === 'object' && 'statusCode' in error) {
        const e = error as { statusCode: number; message: string; data?: { requestId?: string } };
        const statusCode = e.statusCode;
        const message = e.message || 'Unknown error';
        const requestId = e.data?.requestId;

        if (statusCode >= 400 && statusCode < 500) {
          throw new ClientError(statusCode, message, { requestId });
        } else if (statusCode >= 500) {
          throw new ServerError(statusCode, message, { requestId });
        }
      }
      throw error;
    }
  };

  /**
   * Update Sandbox Template
   *
   * @param params - Method parameters
   * @param params.templateName - Template name
   * @param params.input - Template configuration
   * @param params.headers - Custom request headers
   * @param params.config - Optional config override
   * @returns Updated Template object
   */
  updateTemplate = async (params: {
    templateName: string;
    input: $AgentRun.UpdateTemplateInput;
    headers?: Record<string, string>;
    config?: Config;
  }): Promise<$AgentRun.Template> => {
    const { templateName, input, headers, config } = params;

    try {
      const client = this.getClient(config);
      const runtime = new $Util.RuntimeOptions({});

      const response = await client.updateTemplateWithOptions(
        templateName,
        new $AgentRun.UpdateTemplateRequest({ body: input }),
        headers ?? {},
        runtime
      );

      logger.debug(
        `request api updateTemplate, request Request ID: ${response.body?.requestId}\n  request: ${JSON.stringify([templateName, input])}\n  response: ${JSON.stringify(response.body?.data)}`
      );

      return response.body?.data as $AgentRun.Template;
    } catch (error: unknown) {
      if (error && typeof error === 'object' && 'statusCode' in error) {
        const e = error as { statusCode: number; message: string; data?: { requestId?: string } };
        const statusCode = e.statusCode;
        const message = e.message || 'Unknown error';
        const requestId = e.data?.requestId;

        if (statusCode >= 400 && statusCode < 500) {
          throw new ClientError(statusCode, message, { requestId });
        } else if (statusCode >= 500) {
          throw new ServerError(statusCode, message, { requestId });
        }
      }
      throw error;
    }
  };

  /**
   * Get Sandbox Template
   *
   * @param params - Method parameters
   * @param params.templateName - Template name
   * @param params.headers - Custom request headers
   * @param params.config - Optional config override
   * @returns Template object
   */
  getTemplate = async (params: {
    templateName: string;
    headers?: Record<string, string>;
    config?: Config;
  }): Promise<$AgentRun.Template> => {
    const { templateName, headers, config } = params;

    try {
      const client = this.getClient(config);
      const runtime = new $Util.RuntimeOptions({});

      const response = await client.getTemplateWithOptions(templateName, headers ?? {}, runtime);

      logger.debug(
        `request api getTemplate, request Request ID: ${response.body?.requestId}\n  request: ${JSON.stringify([templateName])}\n  response: ${JSON.stringify(response.body?.data)}`
      );

      return response.body?.data as $AgentRun.Template;
    } catch (error: unknown) {
      if (error && typeof error === 'object' && 'statusCode' in error) {
        const e = error as { statusCode: number; message: string; data?: { requestId?: string } };
        const statusCode = e.statusCode;
        const message = e.message || 'Unknown error';
        const requestId = e.data?.requestId;

        if (statusCode >= 400 && statusCode < 500) {
          throw new ClientError(statusCode, message, { requestId });
        } else if (statusCode >= 500) {
          throw new ServerError(statusCode, message, { requestId });
        }
      }
      throw error;
    }
  };

  /**
   * List Sandbox Templates
   *
   * @param params - Method parameters
   * @param params.input - List options
   * @param params.headers - Custom request headers
   * @param params.config - Optional config override
   * @returns List of Template objects
   */
  listTemplates = async (params: {
    input: $AgentRun.ListTemplatesRequest;
    headers?: Record<string, string>;
    config?: Config;
  }): Promise<$AgentRun.ListTemplatesOutput> => {
    const { input, headers, config } = params;

    try {
      const client = this.getClient(config);
      const runtime = new $Util.RuntimeOptions({});

      const response = await client.listTemplatesWithOptions(input, headers ?? {}, runtime);

      logger.debug(
        `request api listTemplates, request Request ID: ${response.body?.requestId}\n  request: ${JSON.stringify([input])}\n  response: ${JSON.stringify(response.body?.data)}`
      );

      return response.body?.data as $AgentRun.ListTemplatesOutput;
    } catch (error: unknown) {
      if (error && typeof error === 'object' && 'statusCode' in error) {
        const e = error as { statusCode: number; message: string; data?: { requestId?: string } };
        const statusCode = e.statusCode;
        const message = e.message || 'Unknown error';
        const requestId = e.data?.requestId;

        if (statusCode >= 400 && statusCode < 500) {
          throw new ClientError(statusCode, message, { requestId });
        } else if (statusCode >= 500) {
          throw new ServerError(statusCode, message, { requestId });
        }
      }
      throw error;
    }
  };

  /**
   * Create Sandbox
   *
   * @param params - Method parameters
   * @param params.input - Sandbox configuration
   * @param params.headers - Custom request headers
   * @param params.config - Optional config override
   * @returns Created Sandbox object
   */
  createSandbox = async (params: {
    input: $AgentRun.CreateSandboxInput;
    headers?: Record<string, string>;
    config?: Config;
  }): Promise<$AgentRun.Sandbox> => {
    const { input, headers, config } = params;

    try {
      const client = this.getClient(config);
      const runtime = new $Util.RuntimeOptions({});

      const response = await client.createSandboxWithOptions(
        new $AgentRun.CreateSandboxRequest({ body: input }),
        headers ?? {},
        runtime
      );

      logger.debug(
        `request api createSandbox, request Request ID: ${response.body?.requestId}\n  request: ${JSON.stringify([input])}\n  response: ${JSON.stringify(response.body?.data)}`
      );

      return response.body?.data as $AgentRun.Sandbox;
    } catch (error: unknown) {
      if (error && typeof error === 'object' && 'statusCode' in error) {
        const e = error as { statusCode: number; message: string; data?: { requestId?: string } };
        const statusCode = e.statusCode;
        const message = e.message || 'Unknown error';
        const requestId = e.data?.requestId;

        if (statusCode >= 400 && statusCode < 500) {
          throw new ClientError(statusCode, message, { requestId });
        } else if (statusCode >= 500) {
          throw new ServerError(statusCode, message, { requestId });
        }
      }
      throw error;
    }
  };

  /**
   * Delete Sandbox
   *
   * @param params - Method parameters
   * @param params.sandboxId - Sandbox ID
   * @param params.headers - Custom request headers
   * @param params.config - Optional config override
   * @returns Deleted Sandbox object
   */
  deleteSandbox = async (params: {
    sandboxId: string;
    headers?: Record<string, string>;
    config?: Config;
  }): Promise<$AgentRun.Sandbox> => {
    const { sandboxId, headers, config } = params;

    try {
      const client = this.getClient(config);
      const runtime = new $Util.RuntimeOptions({});

      const response = await client.deleteSandboxWithOptions(sandboxId, headers ?? {}, runtime);

      logger.debug(
        `request api deleteSandbox, request Request ID: ${response.body?.requestId}\n  request: ${JSON.stringify([sandboxId])}\n  response: ${JSON.stringify(response.body?.data)}`
      );

      return response.body?.data as $AgentRun.Sandbox;
    } catch (error: unknown) {
      if (error && typeof error === 'object' && 'statusCode' in error) {
        const e = error as { statusCode: number; message: string; data?: { requestId?: string } };
        const statusCode = e.statusCode;
        const message = e.message || 'Unknown error';
        const requestId = e.data?.requestId;

        if (statusCode >= 400 && statusCode < 500) {
          throw new ClientError(statusCode, message, { requestId });
        } else if (statusCode >= 500) {
          throw new ServerError(statusCode, message, { requestId });
        }
      }
      throw error;
    }
  };

  /**
   * Stop Sandbox
   *
   * @param params - Method parameters
   * @param params.sandboxId - Sandbox ID
   * @param params.headers - Custom request headers
   * @param params.config - Optional config override
   * @returns Stopped Sandbox object
   */
  stopSandbox = async (params: {
    sandboxId: string;
    headers?: Record<string, string>;
    config?: Config;
  }): Promise<$AgentRun.Sandbox> => {
    const { sandboxId, headers, config } = params;

    try {
      const client = this.getClient(config);
      const runtime = new $Util.RuntimeOptions({});

      const response = await client.stopSandboxWithOptions(sandboxId, headers ?? {}, runtime);

      logger.debug(
        `request api stopSandbox, request Request ID: ${response.body?.requestId}\n  request: ${JSON.stringify([sandboxId])}\n  response: ${JSON.stringify(response.body?.data)}`
      );

      return response.body?.data as $AgentRun.Sandbox;
    } catch (error: unknown) {
      if (error && typeof error === 'object' && 'statusCode' in error) {
        const e = error as { statusCode: number; message: string; data?: { requestId?: string } };
        const statusCode = e.statusCode;
        const message = e.message || 'Unknown error';
        const requestId = e.data?.requestId;

        if (statusCode >= 400 && statusCode < 500) {
          throw new ClientError(statusCode, message, { requestId });
        } else if (statusCode >= 500) {
          throw new ServerError(statusCode, message, { requestId });
        }
      }
      throw error;
    }
  };

  /**
   * Get Sandbox
   *
   * @param params - Method parameters
   * @param params.sandboxId - Sandbox ID
   * @param params.headers - Custom request headers
   * @param params.config - Optional config override
   * @returns Sandbox object
   */
  getSandbox = async (params: {
    sandboxId: string;
    headers?: Record<string, string>;
    config?: Config;
  }): Promise<$AgentRun.Sandbox> => {
    const { sandboxId, headers, config } = params;

    try {
      const client = this.getClient(config);
      const runtime = new $Util.RuntimeOptions({});

      const response = await client.getSandboxWithOptions(sandboxId, headers ?? {}, runtime);

      logger.debug(
        `request api getSandbox, request Request ID: ${response.body?.requestId}\n  request: ${JSON.stringify([sandboxId])}\n  response: ${JSON.stringify(response.body?.data)}`
      );

      return response.body?.data as $AgentRun.Sandbox;
    } catch (error: unknown) {
      if (error && typeof error === 'object' && 'statusCode' in error) {
        const e = error as { statusCode: number; message: string; data?: { requestId?: string } };
        const statusCode = e.statusCode;
        const message = e.message || 'Unknown error';
        const requestId = e.data?.requestId;

        if (statusCode >= 400 && statusCode < 500) {
          throw new ClientError(statusCode, message, { requestId });
        } else if (statusCode >= 500) {
          throw new ServerError(statusCode, message, { requestId });
        }
      }
      throw error;
    }
  };

  /**
   * List Sandboxes
   *
   * @param params - Method parameters
   * @param params.input - List options
   * @param params.headers - Custom request headers
   * @param params.config - Optional config override
   * @returns List of Sandbox objects
   */
  listSandboxes = async (params: {
    input: $AgentRun.ListSandboxesRequest;
    headers?: Record<string, string>;
    config?: Config;
  }): Promise<$AgentRun.ListSandboxesOutput> => {
    const { input, headers, config } = params;

    try {
      const client = this.getClient(config);
      const runtime = new $Util.RuntimeOptions({});

      const response = await client.listSandboxesWithOptions(input, headers ?? {}, runtime);

      logger.debug(
        `request api listSandboxes, request Request ID: ${response.body?.requestId}\n  request: ${JSON.stringify([input])}\n  response: ${JSON.stringify(response.body?.data)}`
      );

      return response.body?.data as $AgentRun.ListSandboxesOutput;
    } catch (error: unknown) {
      if (error && typeof error === 'object' && 'statusCode' in error) {
        const e = error as { statusCode: number; message: string; data?: { requestId?: string } };
        const statusCode = e.statusCode;
        const message = e.message || 'Unknown error';
        const requestId = e.data?.requestId;

        if (statusCode >= 400 && statusCode < 500) {
          throw new ClientError(statusCode, message, { requestId });
        } else if (statusCode >= 500) {
          throw new ServerError(statusCode, message, { requestId });
        }
      }
      throw error;
    }
  };
}
