/**
 * Code Generation Script for AgentRun SDK
 *
 * Generates Control API TypeScript code from YAML configurations.
 * This is the Node.js equivalent of the Python codegen.py + Jinja2 templates.
 *
 * All generated methods use a single object parameter pattern for better extensibility:
 * async methodName(params: { param1: Type1; param2?: Type2; ... }): Promise<ReturnType>
 *
 * Usage: bun run codegen
 */

import * as fs from 'fs';
import * as path from 'path';
import * as yaml from 'yaml';
import { fileURLToPath } from 'node:url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const projectRoot = path.resolve(__dirname, '..');
const configsDir = path.join(projectRoot, 'codegen', 'configs');

const CODE_GEN_HINT = `/**
 * This file is auto generated by the code generation script.
 * Do not modify this file manually.
 * Use the \`bun run codegen\` command to regenerate.
 *
 * ÂΩìÂâçÊñá‰ª∂‰∏∫Ëá™Âä®ÁîüÊàêÁöÑÊéßÂà∂ API ÂÆ¢Êà∑Á´Ø‰ª£Á†Å„ÄÇËØ∑ÂãøÊâãÂä®‰øÆÊîπÊ≠§Êñá‰ª∂„ÄÇ
 * ‰ΩøÁî® \`bun run codegen\` ÂëΩ‰ª§ÈáçÊñ∞ÁîüÊàê„ÄÇ
 */`;

interface MethodParam {
  name: string;
  type: string;
  wrapperType?: string;
  description: string;
  optional?: boolean;
}

interface Method {
  name: string;
  apiName?: string;
  description: string;
  params: MethodParam[];
  returnType: string;
  returnDescription: string;
}

interface Config {
  outputPath: string;
  className: string;
  description: string;
  sdkType?: 'agentrun' | 'devs'; // Which underlying SDK to use
  methods: Method[];
}

/**
 * Convert snake_case to camelCase
 */
function toCamelCase(str: string): string {
  return str.replace(/_([a-z])/g, (_, letter) => letter.toUpperCase());
}

/**
 * Map types from config to TypeScript types
 */
function mapType(configType: string, sdkPrefix: string): string {
  // Basic type mappings (Python-style types in config -> TypeScript)
  const typeMap: Record<string, string> = {
    str: 'string',
    int: 'number',
    float: 'number',
    bool: 'boolean',
    string: 'string',
    number: 'number',
    boolean: 'boolean',
  };

  if (typeMap[configType]) {
    return typeMap[configType];
  }

  // If it starts with uppercase, it's a model type from the SDK
  if (configType.charAt(0) === configType.charAt(0).toUpperCase()) {
    return `${sdkPrefix}.${configType}`;
  }

  return configType;
}

/**
 * Map return types
 */
function mapReturnType(configType: string, sdkPrefix: string): string {
  if (configType.charAt(0) === configType.charAt(0).toUpperCase()) {
    return `${sdkPrefix}.${configType}`;
  }
  return configType;
}

/**
 * Generate the params interface type inline
 */
function generateParamsType(
  method: Method,
  sdkPrefix: string
): { typeString: string; paramNames: string[] } {
  const paramDefs: string[] = [];
  const paramNames: string[] = [];

  for (const param of method.params) {
    const paramName = toCamelCase(param.name);
    const paramType = mapType(param.type, sdkPrefix);
    const optionalMark = param.optional ? '?' : '';
    paramDefs.push(`${paramName}${optionalMark}: ${paramType}`);
    paramNames.push(paramName);
  }

  // Always add optional headers and config
  paramDefs.push('headers?: Record<string, string>');
  paramDefs.push('config?: Config');

  return {
    typeString: `{ ${paramDefs.join('; ')} }`,
    paramNames,
  };
}

/**
 * Generate Control API TypeScript code from config
 */
function generateControlApiCode(config: Config, source: string): string {
  const lines: string[] = [];
  const sdkPrefix = config.sdkType === 'devs' ? '$DevS' : '$AgentRun';
  const sdkPackage =
    config.sdkType === 'devs' ? '@alicloud/devs20230714' : '@alicloud/agentrun20250910';

  // File header
  lines.push(CODE_GEN_HINT);
  lines.push('');
  lines.push(`// Source: ${source}`);
  lines.push('');

  // Imports
  lines.push(`import * as ${sdkPrefix} from "${sdkPackage}";`);
  lines.push(`import * as $Util from "@alicloud/tea-util";`);
  lines.push('');
  lines.push(`import { Config } from "../../utils/config";`);
  lines.push(`import { ControlAPI } from "../../utils/control-api";`);
  lines.push(`import { ClientError, ServerError } from "../../utils/exception";`);
  lines.push(`import { logger } from "../../utils/log";`);
  lines.push('');

  // Class definition
  lines.push(`/**`);
  lines.push(` * ${config.description}`);
  lines.push(` */`);
  lines.push(`export class ${config.className} extends ControlAPI {`);
  lines.push(`  constructor(config?: Config) {`);
  lines.push(`    super(config);`);
  lines.push(`  }`);
  lines.push('');

  // Generate methods
  for (const method of config.methods) {
    const methodName = toCamelCase(method.name);
    const apiName = method.apiName || method.name;
    const apiMethodName = toCamelCase(apiName);

    // Generate params type
    const { typeString: paramsType, paramNames } = generateParamsType(method, sdkPrefix);

    // Return type
    const returnType = mapReturnType(method.returnType, sdkPrefix);

    // Method JSDoc
    lines.push(`  /**`);
    lines.push(`   * ${method.description}`);
    lines.push(`   *`);
    lines.push(`   * @param params - Method parameters`);
    for (const param of method.params) {
      lines.push(`   * @param params.${toCamelCase(param.name)} - ${param.description}`);
    }
    lines.push(`   * @param params.headers - Custom request headers`);
    lines.push(`   * @param params.config - Optional config override`);
    lines.push(`   * @returns ${method.returnDescription}`);
    lines.push(`   */`);

    // Method signature with single object parameter (arrow function for this binding)
    lines.push(`  ${methodName} = async (params: ${paramsType}): Promise<${returnType}> => {`);

    // Destructure params
    const destructureList = [...paramNames, 'headers', 'config'];
    lines.push(`    const { ${destructureList.join(', ')} } = params;`);
    lines.push('');

    // Method body
    lines.push(`    try {`);
    lines.push(`      const client = this.getClient(config);`);
    lines.push(`      const runtime = new $Util.RuntimeOptions({});`);
    lines.push('');

    // Build request call
    const callParams: string[] = [];
    for (const param of method.params) {
      const paramName = toCamelCase(param.name);
      if (param.wrapperType) {
        callParams.push(`new ${sdkPrefix}.${param.wrapperType}({ body: ${paramName} })`);
      } else if (param.optional && param.type.charAt(0) === param.type.charAt(0).toUpperCase()) {
        // Optional model type parameter - create empty object if undefined
        callParams.push(`${paramName} ?? new ${sdkPrefix}.${param.type}({})`);
      } else {
        callParams.push(paramName);
      }
    }
    callParams.push('headers ?? {}');
    callParams.push('runtime');

    lines.push(`      const response = await client.${apiMethodName}WithOptions(`);
    for (let i = 0; i < callParams.length; i++) {
      const comma = i < callParams.length - 1 ? ',' : '';
      lines.push(`        ${callParams[i]}${comma}`);
    }
    lines.push(`      );`);
    lines.push('');

    // Build request params array for logging
    const requestParamsList: string[] = [];
    for (const param of method.params) {
      const paramName = toCamelCase(param.name);
      requestParamsList.push(paramName);
    }

    lines.push(`      logger.debug(`);
    lines.push(
      `        \`request api ${apiMethodName}, request Request ID: \${response.body?.requestId}\\n  request: \${JSON.stringify([${requestParamsList.join(', ')}])}\\n  response: \${JSON.stringify(response.body?.data)}\`,`
    );
    lines.push(`      );`);
    lines.push('');
    lines.push(`      return response.body?.data as ${returnType};`);
    lines.push(`    } catch (error: unknown) {`);
    lines.push(`      if (error && typeof error === "object" && "statusCode" in error) {`);
    lines.push(
      `        const e = error as { statusCode: number; message: string; data?: { requestId?: string } };`
    );
    lines.push(`        const statusCode = e.statusCode;`);
    lines.push(`        const message = e.message || "Unknown error";`);
    lines.push(`        const requestId = e.data?.requestId;`);
    lines.push('');
    lines.push(`        if (statusCode >= 400 && statusCode < 500) {`);
    lines.push(`          throw new ClientError(statusCode, message, { requestId });`);
    lines.push(`        } else if (statusCode >= 500) {`);
    lines.push(`          throw new ServerError(statusCode, message, { requestId });`);
    lines.push(`        }`);
    lines.push(`      }`);
    lines.push(`      throw error;`);
    lines.push(`    }`);
    lines.push(`  };`);
    lines.push('');
  }

  lines.push(`}`);
  lines.push('');

  return lines.join('\n');
}

/**
 * Main function
 */
function main(): void {
  console.log('üöÄ AgentRun SDK Code Generation');
  console.log('================================');
  console.log(`Project root: ${projectRoot}`);
  console.log(`Configs dir: ${configsDir}`);
  console.log('');

  // Check if configs directory exists
  if (!fs.existsSync(configsDir)) {
    console.log('‚ùå No configs directory found, skipping codegen');
    return;
  }

  // Process all YAML config files
  const configFiles = fs
    .readdirSync(configsDir)
    .filter(f => f.endsWith('.yaml') || f.endsWith('.yml'));

  if (configFiles.length === 0) {
    console.log('‚ùå No YAML config files found');
    return;
  }

  console.log(`Found ${configFiles.length} config file(s)`);
  console.log('');

  for (const configFile of configFiles) {
    const configPath = path.join(configsDir, configFile);
    console.log(`üìÑ Processing: ${configFile}`);

    const configContent = fs.readFileSync(configPath, 'utf-8');
    const config = yaml.parse(configContent) as Config;

    // Get output path directly from config (already in TypeScript format)
    const outputPath = config.outputPath;
    const fullOutputPath = path.join(projectRoot, outputPath);

    // Ensure output directory exists
    const outputDir = path.dirname(fullOutputPath);
    if (!fs.existsSync(outputDir)) {
      fs.mkdirSync(outputDir, { recursive: true });
    }

    // Generate code
    const code = generateControlApiCode(config, configFile);

    // Write output
    fs.writeFileSync(fullOutputPath, code, 'utf-8');
    console.log(`   ‚úÖ Generated: ${outputPath}`);
  }

  console.log('');
  console.log('‚ú® Code generation complete!');
}

main();
